<!DOCTYPE html>
<html lang="fr">
<head>
	<meta charset="utf-8">
	<title>WebGL</title>
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<style>
	body {
		margin: 0px;
		background-color: #000000;
		overflow: hidden;
	}
	</style>
</head>
<body>
	<script src="Js/three.js"></script>
	<script src="Js/OrbitControls.js"></script>
	<script src="Js/forme.js"></script>
	<script src="Js/ColladaLoader.js"></script>
	<script src="Js/stats.min.js"></script>
	<script src="Js/WebGL.js"></script>


	<script>
	var camera, scene, renderer;
	var mesh;
	var top, right, left;
	var x, y, z;
	var objects = [];

	init();
	animate();

	function init() {
		camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 1, 6000 );
		camera.position.x = 0;
		camera.position.y = 0;
		camera.position.z = 600;

		/*

		spotLight = new THREE.SpotLight( 0xffffff, 1 );
		spotLight.position.set( 5000, 0, 0 );
		spotLight.angle = 2;
		spotLight.penumbra = 2;
		spotLight.decay = 2;
		spotLight.distance = 500;
		spotLight.intensity = 2;

		spotLight.castShadow = true;
		spotLight.shadow.mapSize.width = 1024;
		spotLight.shadow.mapSize.height = 1024;
		spotLight.shadow.camera.near = 10;
		spotLight.shadow.camera.far = 200;
		scene.add( spotLight );
*/


		var controls = new THREE.OrbitControls( camera );
		scene = new THREE.Scene();
		controls.minDistance = 0;
		controls.maxDistance = 3000;
		controls.maxPolarAngle = (Math.PI / 2);

		scene = new THREE.Scene();

		var path = "Texture/image/background/";
		var format = '.png';
		var urls = [
			path + 'right' + format,
			path + 'left' + format,
			path + 'top' + format,
			path + 'bottom' + format,
			path + 'back' + format,
			path + 'front' + format
		];
		var reflectionCube = THREE.ImageUtils.loadTextureCube(urls);
		reflectionCube.format = THREE.RGBFormat;
		var shader = THREE.ShaderLib[ "cube" ];
		shader.uniforms[ "tCube" ].value = reflectionCube;
		var material = new THREE.ShaderMaterial( {
			fragmentShader: shader.fragmentShader,
			vertexShader: shader.vertexShader,
			uniforms: shader.uniforms,
			depthWrite: false,
			side: THREE.BackSide
		});
		mesh = new THREE.Mesh(new THREE.BoxGeometry(10000, 10000, 10000), material);
		mesh.position.set(0, 0, 0);
		scene.add(mesh);


		//base Troca
		var texture = new THREE.TextureLoader().load( 'Texture/marbre.jpg');
		var geometry = new THREE.BoxBufferGeometry( 3500, 750, 1000 );
		var material = new THREE.MeshBasicMaterial( { map: texture } );
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.set(0, 200, -3000);
		scene.add( mesh );

		//base herbe
		var texture = new THREE.TextureLoader().load( 'Texture/herbe.jpg');
		var geometry = new THREE.BoxBufferGeometry( 2000, -10, -3500 );
		var material = new THREE.MeshBasicMaterial( { map: texture } );
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.set(0, -100, -1000);
		scene.add( mesh );

		//base eau
		var texture = new THREE.TextureLoader().load( 'Texture/water.jpg');
		var geometry = new THREE.BoxBufferGeometry( 1000, -12, -3500 );
		var material = new THREE.MeshBasicMaterial( { map: texture } );
		var mesh = new THREE.Mesh( geometry, material );
		mesh.position.set(0, -100, -1000);
		scene.add( mesh );

		//la fontaine et les ombres
			var loader = new THREE.ColladaLoader();

			loader.load( 'dae/Eiffel.dae', function ( collada ) {

									eiffel = collada.scene;

						eiffel.traverse(function(child) {
						child.castShadow = true;
						child.receiveShadow = true;
						child.frustumCulled = true;
						if( child instanceof THREE.Mesh)
						{
							objects.push(child);
						}
					});

					eiffel.position.set(-300,350,3500);
					eiffel.scale.set(25,25,25);
					eiffel.scale.multiplyScalar(6);
					scene.add( eiffel );
								} );


		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		controls.update();
		window.addEventListener( 'resize', onWindowResize, false );
	}
	function onWindowResize() {
		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();
		renderer.setSize( window.innerWidth, window.innerHeight );
	}
	function animate() {
		requestAnimationFrame( animate );
		//controls.update();
		//mesh.rotation.x += 0.005;
		//mesh.rotation.y += 0.01;
		renderer.render( scene, camera );
	}
	</script>

</body>
</html>
